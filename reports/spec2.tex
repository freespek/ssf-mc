%! TeX root = report.tex

\section{M2: Spec 2: Fold-Based Specification}

\SpecTwo{} addresses some of the limitations inherent in the straightforward
translation of \SpecOne{} from the Python executable specification.

\subsection{Translating Recursive \tlap{} Operators}

The primary goal of \SpecTwo{} is to maintain the semantic structure of
\SpecOne{} while eliminating recursion. In \SpecOne{}, (mutually) recursive
operators model key aspects of protocol behavior, such as the block tree and
block justification. Apalache does not natively support recursive
operators\footnote{\url{https://apalache-mc.org/docs/apalache/principles/recursive.html}},
thus \SpecOne{} cannot not be directly model-checked.

To resolve this, we reformulate \SpecOne{} into \SpecTwo{}, by substituting
(mutually) recursive constructs with bounded
\texttt{fold}~operations\footnote{In functional programming, \texttt{fold} is a
  higher-order function that uses of a given combining operation to build a
  return value over a recursive data structure. It is also known as
\texttt{reduce} in some languages}, which enable the same iterative
computations to be performed in a non-recursive manner.
Consider the following example from \SpecOne{}:

\begin{lstlisting}[language=tla]
RECURSIVE is_ancestor_descendant_relationship(_, _, _)
is_ancestor_descendant_relationship(ancestor, descendant, node_state) ==
    IF ancestor = descendant THEN TRUE
    ELSE IF descendant = node_state.configuration.genesis THEN FALSE
    ELSE
        /\ has_parent(descendant, node_state)
        /\ is_ancestor_descendant_relationship(ancestor, get_parent(descendant, node_state), node_state)
\end{lstlisting}

Its corresponding fold-based formulation is shown below:

\begin{lstlisting}[language=tla]
is_ancestor_descendant_relationship(ancestor, descendant, node_state) ==
    LET FindAncestor(last_block_and_flag, slot) ==
        LET
            last_block == last_block_and_flag[1]
            flag == last_block_and_flag[2]
        IN
        IF flag THEN Pair(last_block, TRUE)
        ELSE IF last_block = node_state.configuration.genesis \/ ~has_parent(last_block, node_state) THEN Pair(last_block, FALSE)
        ELSE LET parent == get_parent(last_block, node_state) IN Pair(parent, parent = ancestor)
    IN
    ApaFoldSeqLeft(FindAncestor, Pair(descendant, descendant = ancestor), MkSeq(MAX_SLOT, LAMBDA i: i))[2]
\end{lstlisting}

\subsection{An Optimization: Flattening Nested Folds}

Initial model checking experiments with \SpecTwo{} revealed significant
challenges related to memory consumption, stemming from the high number of SMT
constraints emitted by Apalache for nested fold operations, which in turn mirror
the complexity of the original nested recursive structures from the Python
specification.

To address these issues, we introduce a manual optimization strategy that
involves flattening nested fold operations. This technique transforms nested
folds into a more manageable structure by employing additional \tlap{} state
variables, similar to memoization or prophecy variables.

For example, we introduce a new \tlap{} state variable
\texttt{PRECOMPUTED\_IS\_ANCESTOR\_DESCENDANT\_RELATIONSHIP} to store
precomputed ancestor-descendant relationships and initialize it with the results
of the fold operation above:

\begin{lstlisting}[language=tla]
LET all_blocks == get_all_blocks(single_node_state) IN
PRECOMPUTED__IS_ANCESTOR_DESCENDANT_RELATIONSHIP =
    [ descendant \in all_blocks |-> { ancestor \in all_blocks : is_ancestor_descendant_relationship(ancestor, descendant, single_node_state) } ]
\end{lstlisting}

Instead of re-evaluating the fold operation for each pair of blocks, we can now
directly access the precomputed results in a more efficient map lookup:

\begin{lstlisting}[language=tla]
are_conflicting(chain1, chain2, node_state) ==
    /\ chain1 \notin PRECOMPUTED__is_ancestor_descendant_relationship[chain2]
    /\ chain2 \notin PRECOMPUTED__is_ancestor_descendant_relationship[chain1]
\end{lstlisting}

\paragraph{Insight.} Auto-translated specifications can provide useful starting
points, but are also likely to introduce unwanted inefficiencies. Automated
tools cannot account for the nuances of the specific context, which can lead to
suboptimal performance. Consequently, leveraging human ingenuity to develop
specifications from the outset can be more effective. When relying on
autogenerated specifications, it becomes crucial to conduct manual optimizations
to ensure efficiency.
