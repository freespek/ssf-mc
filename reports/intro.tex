%! TeX root = report.tex

\section{Introduction}

\colorbox{yellow}{RS, TH: A short intro to the protocol}

\paragraph{}\colorbox{yellow}{TODO:}

We have started this project with the Python specification of accountable
safety in the 3SF Protocol\footnote{URL to the Python specification:
\url{https://github.com/freespek/ssf-mc/3sf.txt}}. The main goal of the project
was to demonstrate accountable safety of this protocol by the means of model
checking.

We have chosen the specification language~\tlap{} and the model checker
Apalache for the following reasons.\ \tlap{} remains a goto language for
specifying consensus algorithms. Among the rich spectrum of
specifications~\cite{tla-examples}, the most notable for our project are the
specifications of Paxos~\cite{lamport2001paxos}, Raft~\cite{Ongaro14}, and
Tendermint~\cite{abs-1807-04938,TendermintSpec2020}. Since consensus algorithms
are quite challenging for classical model checkers like TLC, we choose
Apalache~\cite{Apalache2024,KT19,KonnovKM22}. This model checker utilizes the
SMT solver~Z3~\cite{MouraB08} in the background. Apalache was used for model
checking of agreement and accountable safety of
Tendermint~\cite{TendermintSpec2020}. As added benefit, four of the project
participants developed Apalache in the past and know its strenghts and
weaknesses.

\paragraph{Complexity of (model-checking) the protocol.} The 3SF protocol is
intricate, with a high degree of combinatorial complexity, making it challenging
to reason about. We have observed multiple layers of complexity in the protocol:
\begin{itemize}
  \item The Python specification considers all possible graphs over all proposed
    blocks. From graph theory~\cite{cayley1878theorem}, we know that the number
    of labelled rooted forests on $n$ vertices is ${(n+1)}^{n-1}$. (Observe that
    this number grows faster than the factorial~$n!$.) This is the number of
    possible block graphs that the model checker has to consider for $n$ blocks.
  \item The protocol introduces a directed graph of checkpoints (pairs $(b,n)$
    of a block $b$ and an integer $n$) \emph{on top} of the block graph.
    Validator-signed votes form a third labeled directed graph over pairs of
    checkpoints. In addition, all of these edges have to satisfy arithmetic
    constraints.
  \item Justified and finalized checkpoints introduce an inductive structure
    that the model checker has to reason about. Essentially, the solvers have to
    reason about chains of checkpoints on top of chains of blocks.
  \item Finally, the protocol introduces set cardinalities, both for determining a
    quorum of validators and as a threshold for \textit{AccountableSafety}.
    Cardinalities are known to be a source of inefficiency in automated
    reasoning.
\end{itemize}

\subsection{Key Outcomes}\label{sec:discussion}

% we embed the discussion right in the introduction
\input{discussion}

\subsection{Structure of the report}

\begin{figure}
  \input{artifacts}
  \caption{The relation between the specification artifacts}\label{fig:artifacts}
\end{figure}

Figure~\ref{fig:artifacts} depicts the relations between the specifications
that we have produced in the project:

\begin{enumerate}
    \item We have started with the executable specification in Python.

    \item \SpecOne{}: This is the specification
        \texttt{spec1-2/ffg\_recursive.tla}. It is the result of a manual
        mechanical translation of the original executable specification in
        Python, which can be found in \texttt{ffg.py}. This specification is
        using mutually recursive operators, which are not supported by
        Apalache. As a result, we are not checking this specification. This
        specification is the result of our work in Milestones~1 and~3.
        It is discussed in Section~\ref{sec:spec1}.

    \item \SpecTwo{}: This is the specification \texttt{spec1-2/ffg.tla}. It is
        a manual adaptation of~\SpecOne{}. The main difference
        between~\SpecTwo{} and~\SpecOne{} is that~\SpecTwo{} uses ``folds''
        (also known as ``reduce'') instead of recursion. This specification is
        the result of our work in Milestones~1 and~2. It is discussed in
        Section~\ref{sec:spec2}.

    \item \SpecThree{}: This is the further abstraction of~\SpecTwo{} that uses
        the concept of a state machine, instead of a purely sequential
        specification (such as the Python code). This specification is the
        result of our work in Milestone~2. It is discussed in
        Section~\ref{sec:spec3}.

    \item \SpecFour{}: This is an extension of~\SpecThree{} that contains
        an inductive invariant in~\texttt{spec4/ffg\_inductive.tla}.
        This specification is the result of our work in Milestone~4.
        It is discussed in Section~\ref{sec:spec4}.

    \item \SpecFourB{} contains further abstractions and decomposition of
        configurations. This is the first~\tlap{} specification that allowed us
        to show accountable safety for models of very small size. This
        specification is the result of our work in Milestone~4.
        It is discussed in Section~\ref{sec:spec4b}.

    \item \SpecThreeB{} contains a specification in SMT using the theory of
        finite sets and cardinalities. In combination with the solver
        CVC5~\cite{BarbosaBBKLMMMN22}, this specification allows us to push
        verification of accountable safety even further. This specification is
        the result of our work in Milestone~4. It is discussed in
        Section~\ref{sec:smt}.

    \item \SpecThreeC{} contains a specification in
        Alloy~\cite{jackson2012software,alloytools}. With this specification,
        we manage to check all small configurations that cover the base case
        and one inductive step of the definitions. This specification is the
        result of our work in Milestone~4. It is discussed in
        Section~\ref{sec:alloy}.

    \item Section~\ref{section3} contains the translation rules and proofs
        that were conducted in Milestone~3.

\end{enumerate}

\subsection{Potential extensions of this project}\label{sec:future}

\input{future}

