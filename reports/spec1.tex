%! TeX root = report.tex

\section{M1: Spec 1}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth,angle=-90]{ffg-callgraph.pdf}
    \caption{The callgraph of the 3SF specification}
    \label{fig:your_label}
\end{figure}

    The first specification is obtained by following the principle of least surprise; to the extent that it is possible, without regard to model checking efficiency, we translate Python code to its \tlap{} counterpart with the closest syntax, preserving semantics.

    Despite being a programming language and specification language respectively, Python and \tlap{} overlap somewhat in what they can express. 
    For instance, both allow us to express sets, and then filter those sets by a given predicate to obtain a different set.
    To take a concrete example, observe the definition of $pset\_filter$ in Figure~\ref{py_filter}.
    \begin{figure}
    \begin{lstlisting}[language=Python]
    def pset_filter(p: Callable[[T1], bool], s: PSet[T1]) -> PSet[T1]:
        r: PSet[T1] = pset()

        for e in s:
            if p(e):
                r = r.add(e)

        return r
    \end{lstlisting}
    \caption{$pset\_filter$ definition \label{py_filter}}
    \end{figure}
    %
    Notice that, while filter is not one of the built-in operators of the \emph{pyrsistent} library, it is relatively simple to define a filter operator, such that the set returns contains exactly all of the elements of $s$, for which the Boolean predicate $p$ holds true.
    In \tlap{}, however, filtering is a language primitive, so if we can translate a python set $s$ to a \tlap{} set $\hat{s}$, and a Python predicate $p$ (of the above type) to a \tlap{} predicate $\hat{p}$, we can translate $\mathrm{pset\_filter}(p, s)$ to $\{ x \in \hat{s}\colon \hat{p}(x) \}$.

    We take this idea, and apply it to every definition in the file \emph{pythonic\_code\_generic.py}, attempting to identify \tlap{}-equivalents (w.r.t. semantics) for each defined function. 
    Later on, in milestone 3, we give a formal characterization of all of these equivalencies, in the form of rewriting rules, although for the purposes of this first specification, the entirety of this translation is manual.

    Although it is relevant in the process of translation, we do not give explicit rules for the translation of Python language primitives to \tlap{} in general, since attempting to establish those for the full language would vastly exceed the scope of this project. 
    Some of these constructs are particularly relevant, and we briefly mention them here:
    \paragraph{Assignments and local variables.} There are certain idiosyncrasies to do with the fact that one language is executable, and the other is not. For instance, Python allows for arbitrary variable assignment and reassignment, as well as the introduction of local variables. There are two constructs available in \tlap{} which can be used to express variable assignment:
    \begin{itemize}
      \item state-variable update $a' = e$
      \item LET-IN local operator definition $\mathrm{LET}\; v \defeq e \;\mathrm{IN}\; f$
    \end{itemize}
    to avoid going in to too much detail, it is up to the translator to evaluate which of the two better captures the semantics of the Python code (with, in general, a preference for the LET-IN variant).
    \paragraph{Runtime exceptions.} Python code may throw at any time, sometimes in the form of $\mathrm{Require}$-guards within function definitions. 
    In general, this behavior is impossible to replicate without very convoluted \tlap{} code, so we either have to omit those guards, or return an unspecified value of the correct type if the requirement is not met.

    TODO: operator definitions: \url{https://github.com/saltiniroberto/ssf/blob/ad3ba2c21bc1cd554a870a6e0e4d87040558e129/high_level/common/helpers.py#L20C1-L24C56}

\paragraph{Recursion.} Native \tlap{} supports recursive operators at the language level, but Apalache does not, at the model-checking level. This means that we can translate recursive Python functions as-written in Spec 1, with the knowledge that we will need to remove them in Spec 2 to facilitate model checking.

