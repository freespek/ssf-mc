%! TeX root = report.tex

\section{Spec 4d in Alloy}

Once we saw that our specifications \texttt{Spec 3} and \texttt{Spec 4}
were too challenging for the \tlap{} tools, we have decided to employ
Alloy~\cite{jackson2012software,alloytools}, as an alternative to our tooling.
Alloy has two features that are attractive for our project:

\begin{itemize}

  \item Alloy allows to precisely control the search scope by setting the
      number of objects of particular type in the universe. For example, we can
      restrict the number of checkpoints and votes to 5 and 12, respectively.
      Although we introduced similar restrictions with Apalache, Alloy has even
      finer level of tuning.

  \item Alloy translates the model checking problem to a Boolean satisfiability
      problem (SAT), in constrast to Apalache, which translates it to satisfiability-modulo-theory (SMT).  This
      allows us to run the latest off-the-shelf solvers such as Kissat, the
      winner of the SAT Competition 2024~\cite{SAT-Competition-2024-solvers}.

\end{itemize}

Having \texttt{Spec 4} in~\tlap{}, it was relatively easy for us to write down
the Alloy specification, as \texttt{Spec 4} is already quite abstract. However, as
Alloy's core abstractions are objects and relations between them, the
specification looks quite differently. For example, here is how we declare
signatures for the blocks and checkpoints:

\begin{lstlisting}[language=alloy,columns=fullflexible]
  sig Payload {}
  sig Signature {}
  fact atLeastFourSignatures { #Signature >= 4 }

  sig Block {
    slot: Int,
    body: Payload,
    parent: Block
  }
  sig Checkpoint {
    block: Block,
    slot: Int
  }

  one sig GenesisPayload extends Payload {}
  one sig GenesisBlock extends Block {}
\end{lstlisting}

In contrast to~\texttt{Spec 4}, our Alloy specification does not describe a
state machine, but it specifies an arbitrary single state of the protocol. As
in~\texttt{Spec 4}, we employ the same trick to restrict the justified
checkpoints:

\begin{lstlisting}[language=alloy,columns=fullflexible]
  one sig JustifiedCheckpoints {
    justified: set Checkpoint
  }
  fact justifiedCheckpointsAreJustified {
    all c: JustifiedCheckpoints.justified |
      c.slot = 0 or 3.mul[#justifyingVotes[c].validator] >= 2.mul[#Signature]
  }
\end{lstlisting}

Similar to our experiments with Apalache, we produce examples of configurations
that satisfy simple properties. For example:

\begin{lstlisting}[language=alloy,columns=fullflexible]
  run someFinalizedCheckpoint { some c: Checkpoint |
    isFinalized[c] and c.slot != 0
  }
  for 10 but 6 Block, 6 Checkpoint, 12 Vote, 5 int
\end{lstlisting}

For small search scopes, Alloy quickly finds examples, often in a matter
of seconds.

Ultimately, we are interested in showing that~$\textit{AccountableSafety}$
holds true. To this end, we want Alloy to show that the
formula~$\textit{noAccountableSafety}$ does not have a model (unsatisfiable).
Similar to Apalache, Alloy allows us to show safety for bounded scopes.

\begin{lstlisting}[language=alloy,columns=fullflexible]
  pred noAccountableSafety {
    disagreement and (3.mul[#slashableNodes] < #Signature)
  }
  run noAccountableSafety for 10 but 6 Block, 6 Checkpoint,
                                     4 Signature, 6 FfgVote, 15 Vote, 5 int
\end{lstlisting}

Thus it is interesting to increase these parameter values as much as possible to cover more scenarios, while keeping them small enough that the SAT solver still terminates within reasonable time.
Table~\ref{tab:alloy-mc} summarizes our experiments with Alloy when checking
$\textit{noAccountableSafety}$ with Kissat. As we can see, we have managed to
show accountable safety for chain configurations of up to 6 blocks,
including the genesis block. However, the most interesting configuration of 7 blocks
(on two chains) happens to be quite challenging for Alloy and Kissat.

\begin{table}
    \centering
    \begin{tabular}{rrrrrrrr}
        \tbh{\#}
            & \tbh{blk}
            & \tbh{chk}
            & \tbh{sig}
            & \tbh{ffg}
            & \tbh{votes}
            & \tbh{Time}
            & \tbh{Memory}
            \\ \toprule
        1 & 3 & 5 & 4 & 5  & 12 & 4s & 35M
            \\ \midrule
        2 & 4 & 5 & 4 & 5 & 12 & 10s & 40M
            \\ \midrule
        3 & 5 & 5 & 4 & 5 & 12 & 15s & 45M
            \\ \midrule
        4 & 3 & 6 & 4 & 6 & 15 & 57s & 52M
            \\ \midrule
        5 & 4 & 6 & 4 & 6 & 15 & 167s & 55M
            \\ \midrule
        6 & 5 & 6 & 4 & 6 & 15 & 245s & 57M
            \\ \midrule
        7 & 6 & 6 & 4 & 6 & 15 & 360s & 82M
            \\ \midrule
        8 & 5 & 7 & 4 & 6 & 24 & 1h 27m & 156M
            \\ \midrule
        9 & --- & --- & --- & --- & --- & --- & ---
            \\ \midrule
        10 & 3 & 15 & 4 & 5 & 12 & 31s & 56M
            \\ \midrule
        11 & 4 & 20 & 4 & 5 & 12 & 152s & 94M
            \\ \midrule
        12 & 5 & 25 & 4 & 5 & 12 & 234s & 117M
            \\ \midrule
        13 & 7 & 15 & 4 & 10 & 40 & over 10 days & 300 MB
            \\ \bottomrule
    \end{tabular}
    \caption{Model checking experiments with Alloy and Kissat:
      \textbf{blk} is the number of blocks, \textbf{chk} is the number
      of checkpoints, \textbf{sig} is the number of validator signatures,
      \textbf{ffg} is the number of FFG votes, \textbf{votes} is the number
      of validator votes.
    }\label{tab:alloy-mc}
\end{table}

